# 1C_admission
**Задача:**
---
    
    Курсы бывают нескольких уровней, от 0 до 5 включительно. Прежде чем закрыть курс нужно закрыть его зависимости. Зависимости это всегда курсы уровнем меньше. Например, чтобы закрыть курс “Архитектура.2” 4-го уровня, надо закрыть курс “Архитектура.1” 3-го уровня.
    Студенту кафедры надо закрыть три курса 3-го уровня к концу бакалавриата и один курс 5-го уровня к концу магистратуры. Кроме того, ему надо закрывать по три курса каждый семестр.
    Время студента ограничено. Перед началом учебы он выбирает какие, в итоге, курсы 3-го и 5-го уровня хочет закрыть. Вместе с тем, какие-то курсы 2-го уровня ему нравятся больше, какие-то меньше. То есть, у студента есть приоритеты среди курсов 2-го уровня.  Помогите студенту решить, какие курсы следует выбрать.
    
    Теперь формально.
    Напишите программу, которая получает на вход:
    1) Таблицу зависимостей курсов (она не обязательно совпадает с кафедральной, соблюдён только принцип)
    2) Приоритеты для курсов 2-го уровня.
    3) Выбранные курсы 3-го и 5-го уровней.
    4) Минимальное число курсов, которое нужно закрыть в каждом семестре

    Программа должна вывести список курсов, которые следует выбрать. Они, естественно, должны удовлетворять описанными выше условиям. Выбранных курсов должно быть как можно меньше. Помните, что время студента ограничено. Если минимальное количество набирается несколькими различными списками курсов, то среди них выберите с максимальной суммой приоритетов.
    Важно: иногда в зависимостях предлагается выбор. Например, чтобы закрыть “Тестирование” надо закрыть либо “C++.1” либо “Java.1”.
    Входные и выходные данные представляйте в удобном для вас формате.

___
**Формат входных данных:**
    
На вход подается натуральное число `courses_number` - количество курсов, для которых будут описаны зависимости.
Далее вводится courses_number блоков, описывающих каждый курс в отдельности. Каждый из них имеет вид:

    main_course (номер курса), course_level (его уровень), relations_number (количество курсов, которые необходмо пройти, чтобы открыть данный курс)

В каждом таком блоке после данной следуют еще `relations_number` строк, описывающих зависимости между курсами. 

    choose_number (количество курсов, эквивалентных друг другу, из которых можно выбрать)
    ... (номера этих курсов по порядку в количестве choose_number штук)

Далее вводится количество курсов второго уровня и последовательность из их номеров, где курс, находящийся в начале - наиболее приоритетный, а в конце - наименее.

Последней строкой вводится четыре числа - номер курса пятого уровня и три номера курсов третьего уровня, которые были выбраны.

[Пример ввода](https://pastebin.com/k353U3DE), верный вывод для теста - числа от 0 до 23 последовательно.

___

**Формат выходных данных:**

На вывод подается список курсов, которые необходимо выбрать.

___
**Алгоритм решения:**
---

Обобщим задачу. Дан ориентированный граф без циклов. Найти полный подграф, содержащий выбранные вершины и имеющий минимальную мощность (но >= 21, 7 семестров необходимо выбирать минимум три курса).

Запускаем обход графа (BFS) из выбранной вершины пятого уровня. Так найдем все курсы, от которых он зависит. Не обрабатывая те, в которых нет всех трех нужных вершины третьего уровня.
Если получившегося количества курсов достаточно - выводим ответ. Иначе - добираем недостающие курсы в порядке приоритета.

На данном этапе решение за `O(n**2)`, но это не полная задача.

Осталось разрешить вопрос с альтернативным выбором. Хранить данные будем следующим образом:
если для прохождения данного курса нужно пройти пять курсов уровнем ниже - из нее будут вести ребра пяти различных цветов. 
Причем курсы, имеющие однаковый цвет ребра всегда будут альтернативны между собой.

1) Можно написать полный перебор вариантов (заранее фиксировать, какие цвета будем выбирать). Практически при любых
оптимизациях данное решение все равно будет работать непростительно долго.
   
2) Можно написать динамику по поддеревьям. Преподсчитать ответы для курсов первого уровня, через них - для второго. Далее -
для третьего, но уже с учетом предпочтений по курсам второго уровня (при прочих равных выбираем наиболее предпочтительный).
   
Здесь асимптотика зависит уже от количества вариантов для выбора.

В связи с большим количеством деталей и нюансов в задаче, до конца реализовать ее не удалось. Однако, дальнейшая
последовательность действий ясна: 
1) В функции `GetMoreCourses`, которая призвана увеличить количество курсов до 21, если их не хватало, 
нужно совершить обход для еще одной вершины и набирать недостающие с конца. Так продолжаем, пока не доберем нужное количество.

2) Динамика начата для первого уровня (исходя из входных данных) и для второго уровня (необходимо совершить обход (глубины 1) и выбрать
минимум из ответов на предыдущем уровне). Аналогично для следующих (для третьего оставляем только три нужных вершины).

3) Обработка приоритетов выбора курсов второго уровня также решается проверкой пары условий (будем выбирать эти курсы, где необходимо, в порядке приортета)